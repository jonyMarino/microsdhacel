/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : ADC.C
**     Project   : _19_10
**     Processor : MC9S12A256BCPV
**     Beantype  : ADC
**     Version   : Bean 01.279, Driver 01.07, CPU db: 2.87.260
**     Compiler  : Metrowerks HC12 C Compiler
**     Date/Time : 12/08/2005, 03:02 p.m.
**     Abstract  :
**         This device "ADC" implements an A/D converter,
**         its control methods and interrupt/event handling procedure.
**     Settings  :
**         AD control register         : ATD0CTL2    [130]
**         AD control register         : ATD0CTL3    [131]
**         AD control register         : ATD0CTL4    [132]
**         AD control register         : ATD0CTL5    [133]
**         AD control register         : ATD0STAT0   [134]
**         AD control register         : ATD0STAT1   [139]
**         AD control register         : ATD0CTL23   [130]
**         AD control register         : ATD0CTL45   [132]
**         AD control register         : ATD0TEST1   [137]
**         AD control register         : ATD0DIEN    [141]
**         AD result register          : ATD0DR2     [148]
**         AD result register          : ATD0DR3     [150]
**         Interrupt name              : Vatd0
**         Interrupt enable reg.       : ATD0CTL2    [130]
**         Priority                    : 0
**         User handling procedure     : not specified
**         Number of conversions       : 1
**         AD resolution               : 10-bit
**
**         Input pins
**
**              Port name              : AD0
**              Bit number (in port)   : 2
**              Bit mask of the port   : 4
**              Port data register     : PORTAD0     [143]
**
**              Port name              : AD0
**              Bit number (in port)   : 3
**              Bit mask of the port   : 8
**              Port data register     : PORTAD0     [143]
**
**         Initialization:
**              Conversion             : Enabled
**              Event                  : Enabled
**     Contents  :
**         Start - byte ADC_Start(void);
**         Stop  - byte ADC_Stop(void);
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2004
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/


/* MODULE ADC. */

#pragma MESSAGE DISABLE C5703          /* Disable warning C5703 "Parameter is not referenced" */
#pragma MESSAGE DISABLE C4002          /* Disable warning C4002 "Result not used is ignored" */
#pragma MESSAGE DISABLE C12056         /* Disable warning C12056 "SP debug info incorrect because of optimization or inline assembler" */

#include "ADC.h"
#include "Mydefines.h"
#pragma DATA_SEG ADC_DATA                                            
#pragma CODE_SEG ADC_CODE                     
#pragma CONST_SEG ADC_CONST            /* Constant section for this module */

#define STOP            0              /* STOP state           */
#define MEASURE         1              /* MESURE state         */
#define CONTINUOUS      2              /* CONTINUOUS state      */
#define SINGLE          3              /* SINGLE state         */
unsigned long int VZ;
extern long int TA;		//Temperatura ambiente
bool ADfinish;
bool AD_proc;
static bool OutFlg;                    /* Measurement finish flag */
static byte SumChan;                   /* Number of measured channels */
volatile static byte ModeFlg= STOP;          /* Current state of device */
unsigned long int ADC_OutV[CANTIDAD_CANALES+2];

/* Array of measured values */

/*
** ===================================================================
**     Method      :  ADC_Interrupt (bean ADC)
**
**     Description :
**         This method is internal. It is used by Processor Expert
**         only.
**
** ===================================================================
//?? La version de dos canales mide en cada ciclo 3 valores V1V2Vz en uno
y V1V2VTa en otro.

Se hacen  KNMEDCH = 4444 conjuntos de medicion de 8 veces cada valor 
y se hace el promedio.

La entrada es de -10 a +50 mV.
Como el AD trabaja solo con esñales positivas se le coloca un offset de 0,58V

El maximo de la salida del ad acondicionada es 10000 cuentas para 50 mV

El rango total es 12000 cuentas (10k para positivo y 2k para negativo)
La ind. del inst es:
12000->10000
2000->0
0-> -2000

Si llegara justo al maximo que es para 10 bit = 1024 cuentas. Para el maximo de
 12000 hay que dividir por:

KDIV_AD = (KNMEDCH * 8 * 1024) / 12000 = 3033 

Como no estoy en el maximo, lo ajuste experimentalmente a 2900
Las constantes de medicion de temperatura ambiente se determinaron 
experimentalmente.
*/
  

#define KNMEDCH     4444
#define KDIV				12554
//#define KDIV_AD     ((KNMEDCH * 8 * 1024) / KDIV)
#define KDIV_AD   2545
#define K2 716000 			/* Resta a la entrada de T amb. */
#define K3 2666 			/* divide el resultado de la resta anterior */


#pragma CODE_SEG __NEAR_SEG NON_BANKED     
ISR(ADC_Interrupt)
{ static unsigned short ADCont; 
  extern int PRam[PARAMETROS];	          //PARAMETROS en Flash
  extern long int Vx[CANTIDAD_CANALES];
  static bool vz;      
  extern byte ADFinish_Cont;        

 if (ModeFlg == STOP)                 /* Test if the device is in an allowed mode */
    return;                          /* if not, return from the interrupt */ 

  ADC_OutV[SumChan] += ATDDR0;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR1;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR2;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR3;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR4;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR5;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR6;         /* Save measured value */
  ADC_OutV[SumChan] += ATDDR7;         /* Save measured value */
  
  ADCont++;							 // Aumentar Contador
  
  if (ADCont==KNMEDCH){		// ya van KNMEDCH mediciones???
  ADC_Stop();						// Detener el ADC
  ADCont=0;							// Resetear el contador
  
   
   
   
   if (SumChan<CANTIDAD_CANALES){      // se midio algun canal de proceso ???  
   Vx[SumChan]=(ADC_OutV[SumChan]/KDIV_AD) - (VZ/KDIV_AD);	 




   }else  if(SumChan==CANTIDAD_CANALES){							// se midio el canal de Temp. Amb. ???
   TA = (ADC_OutV[2]-VZ+K2) ; 				// restar VZ y K2
   TA /= K3;													// dividirlo por K3
    
    
   }else if(SumChan==CANTIDAD_CANALES+1)VZ=ADC_OutV[CANTIDAD_CANALES+1];	// Se midio el canal de VZ???
   
   ADC_OutV[SumChan]=0;	 // resetear el acumulador del canal
    
   
/////////////////////////ELECCION PROXIMO CANAL////////////////////////   
   SumChan++;					 // Seleccionar proximo canal

    if (SumChan>CANTIDAD_CANALES){			 //	 es el prox can mayor que dos???
    SumChan=0;					 // vuelvo a empezar
    }
    if (SumChan>CANTIDAD_CANALES-1) {		// el prox can es VZ o TA??? 
    if (vz) {						// vz=TRUE?? Leer VZ
      vz=FALSE;					//vz=FALSE
    }else{							//vz=FALSE?? 
    vz=TRUE;						//vz=TRUE
    SumChan++;					//Leer chan TA
    }
   }

  if (SumChan!=0)				// no se vuelve a empezar???
  ADC_Start(SumChan);		// Comenzar mediciones del siguiente canal
  else {								// se vuelve a empezar???
    ADfinish=TRUE;			// La Flash ya puede escribir
    AD_proc=TRUE;       //ejecutar los procesos con los valores del AD
  }
  }
    
  OutFlg = TRUE;                     /* Measured values are available */


}

#pragma CODE_SEG ADC_CODE                     
/*
** ===================================================================
**     Method      :  ADC_Start (bean ADC)
**
**     Description :
**         This method starts continuous conversion of the A/D
**         channels. When each measurement on all channels has
**         finished the <OnEnd > event may be invoked. This method
**         is not available if the <interrupt service> is disabled
**         and the device doesn't support the continuous mode. Note:
**         If time of measurement is too short and the instruction
**         clock is too slow then the conversion complete interrupt
**         and its handler may cause a system overflow.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already
**                           running
** ===================================================================
*/
byte ADC_Start(char chan)
{
  if (ModeFlg != STOP)                 /* Is the device in running mode? */
    return ERR_BUSY;                   /* If yes then error */
  ModeFlg = CONTINUOUS;                /* Set state of device to the continuos mode */
  OutFlg = FALSE;                      /* Output values aren't available */
  ADfinish = FALSE;
  /* ATD0CTL5: DJM=1,DSGN=0,SCAN=1,MULT=0,??=0,CC=X,CB=X,CA=X */
   #if CANTIDAD_CANALES == 1
   if (chan == 0) ATDCTL5 = 166;            // vx1         /* Start conversions */
   else if (chan==1) ATDCTL5 = 164;					//Tamb
   else ATDCTL5 = 167;											// vz
   #elif CANTIDAD_CANALES == 2
   if (chan == 0) ATDCTL5 = 166;            // vx1         /* Start conversions */
   else if (chan==1) ATDCTL5 = 165;					//vx2
   else if (chan==2) ATDCTL5 = 164;					//Tamb
   else ATDCTL5 = 167;											// vz
   #endif
  SumChan=chan;
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  ADC_Stop (bean ADC)
**
**     Description :
**         This method stops the continuous measurement, which had
**         been started by <Start> method, or this method disables a
**         trigger mode which has been enabled by <EnableInt(Chan)
**         Trigger> or <EnableExt(Chan)Trigger> method (if these are
**         supported by HW). This method is available if at least
**         one of <Start>, <EnableInt(Chan)Trigger> or
**         <EnableExt(Chan)Trigger> methods is supported by A/D
**         converter device and it is enabled to be generated.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already
**                           running
** ===================================================================
*/
byte ADC_Stop(void)
{
  if (ModeFlg != CONTINUOUS)           /* Is the device in different mode than "continuos"? */
    return ERR_BUSY;                   /* If yes then error */
  /* ATD0CTL3: ??=0,S8C=0,S4C=0,S2C=0,S1C=1,FIFO=0,FRZ1=0,FRZ0=0 */
  ATDCTL3 = 0;                        /* Abort current measurement */
  ModeFlg = STOP;                      /* Set state of device to the stop mode */
  return ERR_OK;                       /* OK */
}



/* END ADC. */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 2.95 [03.62]
**     for the Freescale HCS12 series of microcontrollers.
**
** ###################################################################
*/
