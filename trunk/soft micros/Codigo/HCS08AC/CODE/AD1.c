/** ###################################################################
**     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : AD1.C
**     Project   : ADC_TEMP_VZ
**     Processor : MC9S08AC128CLK
**     Beantype  : ADC
**     Version   : Bean 01.452, Driver 01.21, CPU db: 3.00.021
**     Compiler  : CodeWarrior HCS08 C Compiler
**     Date/Time : 26/11/2008, 14:35
**     Abstract  :
**         This device "ADC" implements an A/D converter,
**         its control methods and interrupt/event handling procedure.
**     Settings  :
**         AD control register         : ADC1SC1     [$0010]
**         AD control register         : ADC1CFG     [$0016]
**         AD control register         : ADC1RH      [$0012]
**         AD control register         : ADC1RL      [$0013]
**         AD control register         : ADC1CVH     [$0014]
**         AD control register         : ADC1CVL     [$0015]
**         AD control register         : ADC1SC2     [$0011]
**         AD control register         : APCTL1      [$0017]
**         AD control register         : APCTL2      [$0018]
**         AD result register          : ADCres      [$0012]
**         AD result register          : ADCres      [$0012]
**         AD result register          : ADCres      [$0012]
**         AD result register          : ADCres      [$0012]
**         Interrupt name              : Vadc1
**         Priority                    : 
**         User handling procedure     : AD1_OnEnd
**         Number of conversions       : 1
**         AD resolution               : 10-bit
**
**         Input pins
**
**              Port name              : PTB
**              Bit number (in port)   : 2
**              Bit mask of the port   : $0004
**              Port data register     : PTBD        [$0002]
**              Port control register  : PTBDD       [$0003]
**
**              Port name              : PTB
**              Bit number (in port)   : 3
**              Bit mask of the port   : $0008
**              Port data register     : PTBD        [$0002]
**              Port control register  : PTBDD       [$0003]
**
**
**              Port name              : PTB
**              Bit number (in port)   : 4
**              Bit mask of the port   : $0010
**              Port data register     : PTBD        [$0002]
**              Port control register  : PTBDD       [$0003]
**
**         Initialization:
**              Conversion             : Enabled
**              Event                  : Enabled
**         High speed mode
**             Prescaler               : divide-by-8
**     Contents  :
**         Enable             - byte AD1_Enable(void);
**         Disable            - byte AD1_Disable(void);
**         Start              - byte AD1_Start(void);
**         Stop               - byte AD1_Stop(void);
**         Measure            - byte AD1_Measure(bool WaitForResult);
**         EnableAutoCompare  - byte AD1_EnableAutoCompare(bool CompareType, word CompareValue);
**         DisableAutoCompare - byte AD1_DisableAutoCompare(void);
**
**     (c) Copyright UNIS, spol. s r.o. 1997-2008
**     UNIS, spol. s r.o.
**     Jundrovska 33
**     624 00 Brno
**     Czech Republic
**     http      : www.processorexpert.com
**     mail      : info@processorexpert.com
** ###################################################################*/


/* MODULE AD1. */

#include "Events.h"
#include "AD1.h"
#include "PE_Types.h"


static void ClrSumV(void);
/*
** ===================================================================
**     Method      :  ClrSumV (bean ADC)
**
**     Description :
**         The method clears the internal buffers used to store sum of a 
**         number of last conversions.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define STOP            0              /* STOP state           */
#define MEASURE         1              /* MESURE state         */
#define CONTINUOUS      2              /* CONTINUOS state      */
#define SINGLE          3              /* SINGLE state         */
#define ValorListoCh1   4
#define ValorListoCh2   5
#define ValorListoCh3   6
#define ValorListoCh4   7

#define PENDIENTE_DIODO -127/100 //-0.127030205 *10
#define ORDENADA_DIODO  2726    //272.6193737 *10


static const  byte Channels[4] = {0x62,0x63,0x64,0x65};  /* Contents for the device control register */

static bool EnUser;                    /* Enable/Disable device */
static byte OutFlg;                    /* Measurement finish flag */
static byte ModeFlg;                   /* Current state of device */
static long acumuladorChannel1;               //acumula los valores de N conversiones
static long acumuladorChannel2;               //acumula los valores de N conversiones
static long acumuladorChannel3;
static long acumuladorChannel4;
static unsigned int cantConverCh1;            //(N)carga la cantidad de conversiones por muestras
static unsigned int cantConverCh2;            //(N)carga la cantidad de conversiones por muestras
static unsigned int cantConverCh3;
static unsigned int cantConverCh4;
static unsigned int valorCh1;
static unsigned int valorCh2;
static unsigned int valorCh3;
static unsigned int valorCh4;
static unsigned int cantConverCh1Hold;        //retiene el valor de cantConverCh1
static unsigned int cantConverCh2Hold;        //retiene el valor de cantConverCh2
static unsigned int cantConverCh3Hold;
static unsigned int cantConverCh4Hold;
byte channelHold;
TWREG valor;
unsigned int VZ;




/*
** ===================================================================
**     Method      :  AD1_Interrupt (bean ADC)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes event(s) of the bean.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
ISR(AD1_Interrupt)
{
  //ADC1SC1 = ADC1SC1 & 0x7f ;           //Borro la bandera de interrup. 
  if (ModeFlg == STOP) {               /* If the driver is in STOP mode */
    (void)ADC1RL;                      /* Clear interrupt flag */
    return;                            /* Return from interrupt */
  }
  if (ModeFlg != SINGLE) {
   valor.b.high = ADC1RH;               /* Save measured value */
   valor.b.low = ADC1RL;                /* Save measured value */                   
   OutFlg = 0x03;                       /* Measured values are available */
   AD1_OnEnd();                         /* Invoke user event */
      
   if (ModeFlg == MEASURE) {            /* Is the device in the measure state? */
    ModeFlg = STOP;                     /* Set the device to the stop mode */
    return;                             /* Return from interrupt */
      }
  }
}

 
 void AD1_OnEnd(void)
{
  
 if(cantConverCh1){
  cantConverCh1--;
  acumuladorChannel1= acumuladorChannel1+ valor.w;
  if(!cantConverCh1){
    valorCh1 = ((long)acumuladorChannel1 - VZ)/cantConverCh1Hold;
    OutFlg = ValorListoCh1;
    AD1_Stop();
  }
 } else if(cantConverCh2){
    cantConverCh2--;
    acumuladorChannel2= acumuladorChannel2+ valor.w;
    if(!cantConverCh2){
      valorCh2 = ((long)acumuladorChannel2 - VZ)/cantConverCh2Hold;
      OutFlg = ValorListoCh2;
      AD1_Stop();
    }
 } else if(cantConverCh3){
    cantConverCh3--;
    acumuladorChannel3= acumuladorChannel3+ valor.w;
    if(!cantConverCh3){
      valorCh3 = (long)acumuladorChannel3/cantConverCh3Hold;
      OutFlg = ValorListoCh3;
      AD1_Stop();
    }
  } else if(cantConverCh4){
    cantConverCh4--;
    acumuladorChannel4= acumuladorChannel4+ valor.w;
    if(!cantConverCh4){
      valorCh4 = (long)acumuladorChannel4/cantConverCh4Hold;
      OutFlg = ValorListoCh4;
      AD1_Stop();
    }


  }

}
 
/*
** ===================================================================
**     Method      :  ClrSumV (bean ADC)
**
**     Description :
**         The method clears the internal buffers used to store sum of a 
**         number of last conversions.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void ClrSumV(void)
{
  valor.w = 0;                     /* Set variable for storing measured values to 0 */
  
}

/*
** ===================================================================
**     Method      :  AD1_HWEnDi (bean ADC)
**
**     Description :
**         Enables or disables the peripheral(s) associated with the bean.
**         The method is called automatically as a part of the Enable and 
**         Disable methods and several internal methods.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void AD1_HWEnDi(void)
{
  if (EnUser) {                        /* Enable device? */
    if (ModeFlg) {                     /* Start or stop measurement? */
      OutFlg = FALSE;                  /* Output values aren't available */
      ClrSumV();                       /* Clear measured values */
      ADC1SC1 = Channels[channelHold]; /* If yes then start the conversion */
    }
  }
  else {
    ADC1SC1 = 0x1F;                    /* Disable the device */
  }
}

/*
** ===================================================================
**     Method      :  AD1_Enable (bean ADC)
**
**     Description :
**         Enables A/D converter bean. <Events> may be generated
**         (<DisableEvent>/<EnableEvent>). If possible, this method
**         switches on A/D converter device, voltage reference, etc.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte AD1_Enable(void)
{
  if (EnUser) {                        /* Is the device enabled by user? */
    return ERR_OK;                     /* If yes then set the flag "device enabled" */
  }
  EnUser = TRUE;                       /* Set the flag "device enabled" */
  AD1_HWEnDi();                        /* Enable the device */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  AD1_Disable (bean ADC)
**
**     Description :
**         Disables A/D converter bean. No <events> will be generated.
**         If possible, this method switches off A/D converter device,
**         voltage reference, etc.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte AD1_Disable(void)
{
  if (!EnUser) {                       /* Is the device disabled by user? */
    return ERR_OK;                     /* If yes then OK */
  }
  EnUser = FALSE;                      /* If yes then set the flag "device disabled" */
  AD1_HWEnDi();                        /* Enable the device */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  AD1_Start (bean ADC)
**
**     Description :
**         This method starts continuous conversion on all channels
**         that are set in the bean inspector. When each measurement on
**         all channels has finished the <OnEnd > event may be invoked.
**         This method is not available if the <interrupt service> is
**         disabled and the device doesn't support the continuous mode.
**         Note: If time of measurement is too short and the
**         instruction clock is too slow then the conversion complete
**         interrupt and its handler may cause a system overflow.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already running
** ===================================================================
*/
byte AD1_Start(void)
{
 
   
  if (!EnUser) {                       /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  if (ModeFlg != STOP) {               /* Is the device in running mode? */
    return ERR_BUSY;                   /* If yes then error */
  }
  
  ModeFlg = CONTINUOUS;                /* Set state of device to the continuos mode */
  AD1_HWEnDi();                        /* Enable the device */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  AD1_Stop (bean ADC)
**
**     Description :
**         This method stops the continuous measurement or disables
**         a trigger mode (if supported by HW), which has been
**         started by one of the following methods:
**         Version specific information for Freescale HCS08 and HC08
**         derivatives ] 
**         - <Start> 
**         - <EnableIntChanTrigger>
**         - <EnableExtChanTrigger>
**         The Stop method is available if one of the previously
**         mentioned methods is supported by A/D converter device
**         and is enabled to be generated.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_BUSY - No continuous measurement is
**                           running. Neither internal trigger nor
**                           external trigger have been enabled (if
**                           these are supported by HW).
** ===================================================================
*/
byte AD1_Stop(void)
{
  if (ModeFlg != CONTINUOUS) {         /* Is the device in different mode than "continuos"? */
    return ERR_BUSY;                   /* If yes then error */
  }
  ModeFlg = STOP;                      /* Set state of device to the stop mode */
  ADC1SC1 = 0x1F;                      /* Abort the current conversion */
  cantConverCh1=0;            //(N)carga la cantidad de conversiones por muestras
  cantConverCh2=0;            //(N)carga la cantidad de conversiones por muestras
  cantConverCh3=0;
  cantConverCh4=0;
 
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  AD1_Measure (bean ADC)
**
**     Description :
**         This method performs one measurement on all channels that
**         are set in the bean inspector. (Note: If the <number of
**         conversions> is more than one the conversion of A/D channels
**         is performed specified number of times.)
**     Parameters  :
**         NAME            - DESCRIPTION
**         WaitForResult   - Wait for a result of a
**                           conversion. If <interrupt service> is
**                           disabled, A/D peripheral doesn't support
**                           measuring all channels at once or Autoscan
**                           mode property isn't enabled and at the same
**                           time the <number of channel> is greater
**                           than 1, then the WaitForResult parameter is
**                           ignored and the method waits for each
**                           result every time. If the <interrupt
**                           service> is disabled and a <number of
**                           conversions> is greater than 1, the
**                           parameter is ignored and the method also
**                           waits for each result every time.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled
**                           ERR_BUSY - A conversion is already running
** ===================================================================
*/
#pragma MESSAGE DISABLE C5703 /* WARNING C5703: Parameter declared but not referenced */
byte AD1_Measure(bool WaitForResult)
{
  if (!EnUser) {                       /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  if (ModeFlg != STOP) {               /* Is the device in different mode than "stop"? */
    return ERR_BUSY;                   /* If yes then error */
  }
  ModeFlg = MEASURE;                   /* Set state of device to the measure mode */
  AD1_HWEnDi();                        /* Enable the device */
  if (WaitForResult) {                 /* Is WaitForResult TRUE? */
    while (ModeFlg == MEASURE) {}      /* If yes then wait for end of measurement */
  }
  return ERR_OK;                       /* OK */
}


/*
** ===================================================================
**     Method      :  AD1_Init (bean ADC)
**
**     Description :
**         Initializes the associated peripheral(s) and the bean's 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void AD1_Init(void)
{
   VZ = 0;
  EnUser = TRUE;                       /* Enable device */
  OutFlg = FALSE;                      /* No measured value */
  ModeFlg = STOP;                      /* Device isn't running */
  cantConverCh1 = 0;
  cantConverCh2 = 0;
  cantConverCh3 = 0;
  cantConverCh4 = 0;
  /* ADC1SC2: ADACT=0,ADTRG=0,ACFE=0,ACFGT=0,??=0,??=0,??=0,??=0 */
  setReg8(ADC1SC2, 0x00);              /* Disable HW trigger and autocompare */ 
  /* ADC1CFG: ADLPC=0,ADIV1=1,ADIV0=1,ADLSMP=1,MODE1=1,MODE0=0,ADICLK1=1,ADICLK0=1 */
  setReg8(ADC1CFG, 0x7b);              /* Set prescaler bits */ 
  /* ADC1SC1: COCO=0,AIEN=0,ADCO=0,ADCH4=1,ADCH3=1,ADCH2=1,ADCH1=1,ADCH0=1 */
  setReg8(ADC1SC1, 0x1F);              /* Disable the module */ 
  APCTL1 = APCTL1 | 0X3c; 
  //AD1_HWEnDi();                        /* Enable/disable device according to the status flags */
  
  channelHold = 3;                                  //CALCULO LA TENSION VZ 
  cantConverCh3 = setFrecMuestreo(TimEnMues500ms);  //PARA USARLA EN LOS 
  cantConverCh3Hold = cantConverCh3;                //POSTERIORES CALCULOS
  AD1_Start();
  
  while(OutFlg != ValorListoCh3);
  VZ = ADC_getVZ();
}                                                     


unsigned int setFrecMuestreo (frecuencias frec) {

 unsigned int cantConver;
 
 switch(frec)
  {
    
   case TimEnMues100ms:cantConver=1095;return cantConver; break;
   case TimEnMues250ms:cantConver=2739;return cantConver; break;
   case TimEnMues500ms:cantConver=5479;return cantConver;break;
   case TimEnMues1s:cantConver=10958;return cantConver;break;
    
    default:cantConver=1;return cantConver;break; }   
 
}

/*
  chan:
    0 CHANNEL 1 (pin 48)
    1 CHANNEL 2 (pin 49)
    2 CHANNEL 3(mide la tension VZ,pin 50)
    3 CHANNEL 4(mide la temperatura,pin 51)

*/

void selecChannel(byte chan){  

  channelHold = chan;
  acumuladorChannel1 = 0;
  acumuladorChannel2 = 0;
  acumuladorChannel3 = 0;
  acumuladorChannel4 = 0;
  OutFlg = FALSE;
  
   switch(chan)
  {
    case 0:cantConverCh1 = setFrecMuestreo(TimEnMues100ms); cantConverCh1Hold = cantConverCh1; break;
    case 1:cantConverCh2 = setFrecMuestreo(TimEnMues250ms); cantConverCh2Hold = cantConverCh2; break;
    case 2:cantConverCh3 = setFrecMuestreo(TimEnMues500ms); cantConverCh3Hold = cantConverCh3; break;
    case 3:cantConverCh4 = setFrecMuestreo(TimEnMues1s); cantConverCh4Hold = cantConverCh4; break;
    
  }   
 
  
  EnUser = TRUE;
  AD1_Start();                      //modo continuo
}

 /* AVISA CUANDO SE PUEDE LEER EL VALOR  */

bool ADC_listo(byte chan){

   switch(chan)
  {
    case 0:if(OutFlg == ValorListoCh1)
            return TRUE;
           else
              return FALSE;
              break;
    case 1:if(OutFlg == ValorListoCh2) 
              return TRUE;
           else
              return FALSE;
              break;
    case 2:if(OutFlg == ValorListoCh3) 
              return TRUE;
           else
              return FALSE;
              break;
   case 3:if(OutFlg == ValorListoCh4) 
              return TRUE;
           else
              return FALSE;
              break;                     
    
  }   

}

/*
** ===================================================================
**     Method      :  ADC_getTA 
**
**     Description :
**         Devuelve el valor medido para la temperatura ambiente
**     Parameters  : None
**     Returns     :
**         ---             _ Valor medido
** ===================================================================
*/

unsigned int ADC_getTA(void){
  
  bool listo;
  listo = ADC_listo(3); //es verdadero cuando ya calculo el promedio
  
  if(listo){
    
  valorCh4 = (long)valorCh4 *PENDIENTE_DIODO + ORDENADA_DIODO;
    return valorCh4;
  }
}


unsigned int ADC_getVZ(void){
  
  bool listo;
  listo = ADC_listo(2); //es verdadero cuando ya calculo el promedio
  
  if(listo)
    return valorCh3;
}

/*
** ===================================================================
**     Method      :  ADC_getVal 
**
**     Description :
**         Devuelve el valor medido para el canal
**     Parameters  : chan  _ Numero de canal
**     Returns     :
**         ---             _ Valor medido
** ===================================================================
*/
unsigned int ADC_getVal(byte chan){
 
  bool listo;
  listo = ADC_listo(chan); //es verdadero cuando ya calculo el promedio
 
 switch(chan)
  {
    case 0:return valorCh1; break;
    case 1:return valorCh2; break;

}
}
/* END AD1. */

/*
** ###################################################################
**
**     This file was created by UNIS Processor Expert 3.03 [04.07]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
